namespace MTTFC
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Threading;

    public static class ConvertServiceConverter
    {
        public static void Convert(ConvertService.LogAction log, List<ModelFile> models, ConvertServiceParameters parameters)
        {
            log("Converting..");

            foreach (var file in models)
            {
                var directoryPath = Path.Combine(parameters.ConvertDirectory, file.Structure);

                var relativePath = parameters.PathStyle == PathStyle.Kebab
                    ? ConvertServiceHelper.ToKebabCasePath(file.Structure)
                    : file.Structure;

                DirectoryInfo di = Directory.CreateDirectory(Path.Combine(parameters.ConvertDirectory, relativePath));
                di.Create();

                string fileName = (parameters.PathStyle == PathStyle.Kebab ? ConvertServiceHelper.ToKebabCase(file.Name) : ConvertServiceHelper.ToCamelCase(file.Name))
                    + (parameters.IsModelInTSFileName ? ".model" : "")
                    + ".ts";
                log("Creating file {0}", fileName);
                string saveDir = Path.Combine(di.FullName, fileName);
                log("Save path is {0}", saveDir);

                using var stream = GetStream(saveDir, 0);
                using var f =
                    new StreamWriter(stream, System.Text.Encoding.UTF8, 1024, false);
                var importing = false;  //only used for formatting
                var imports = new List<string>();  //used for duplication

                if (parameters.IsAutoGeneratedTag)
                {
                    f.WriteLine("/* Auto Generated */");
                    f.WriteLine();
                }

                if (file.IsEnum)
                {
                    f.WriteLine(
                        "export enum "
                        + file.Name
                        // + (String.IsNullOrEmpty(file.Inherits) ? "" : (" : " + file.Inherits)) //typescript doesn't extend enums like c#
                        + " {"
                        );

                    foreach (var obj in file.EnumObjects)
                    {
                        if (!String.IsNullOrEmpty(obj.Name))
                        {  //not an empty obj
                            var tsName = ConvertServiceHelper.ToCamelCase(obj.Name);
                            var str = tsName;
                            if (parameters.EnumValues == EnumValues.Strings)
                            {
                                str += " = '" + tsName + "'";
                            }
                            else if (!obj.IsImplicit)
                            {
                                str += " = " + obj.Value;
                            }
                            str += ",";

                            f.WriteLine("    " + str);
                        }
                    }

                    f.WriteLine("}");
                }
                else
                {
                    foreach (var obj in file.Objects)
                    {
                        if (!string.IsNullOrEmpty(file.Inherits))
                        {
                            importing = true;

                            var import = "import { " + file.Inherits + " } from \""
                                + (parameters.PathStyle == PathStyle.Kebab ? ConvertServiceHelper.ToKebabCasePath(file.InheritenceStructure) : file.InheritenceStructure) + "\";";

                            if (!imports.Contains(import))
                            {
                                f.WriteLine(import);
                                imports.Add(import);
                            }
                        }

                        if (obj.UserDefined)
                        {
                            importing = true;
                            var import = "import { " + obj.Type + " } from \""
                                + (parameters.PathStyle == PathStyle.Kebab ? ConvertServiceHelper.ToKebabCasePath(obj.UserDefinedImport) : obj.UserDefinedImport) + "\";";

                            if (!imports.Contains(import))
                            {
                                f.WriteLine(import);
                                imports.Add(import);
                            }
                        }

                        if (obj.IsContainer)
                        {
                            foreach (LineObject innerObj in obj.Container)
                            {
                                if (innerObj.UserDefined)
                                {
                                    importing = true;
                                    var import = "import { " + innerObj.Type + " } from \""
                                        + (parameters.PathStyle == PathStyle.Kebab ? ConvertServiceHelper.ToKebabCasePath(innerObj.UserDefinedImport) : innerObj.UserDefinedImport) + "\";";

                                    if (!imports.Contains(import))
                                    {
                                        f.WriteLine(import);
                                        imports.Add(import);
                                    }
                                }
                            }
                        }
                    }

                    if (parameters.Implements.ContainsKey(file.Name)) {
                        var implements = parameters.Implements[file.Name];

                        if (string.IsNullOrEmpty(implements.from))
                            continue;

                        importing = true;

                        var import = "import { " + implements.type + " } from \""
                            + implements.from + "\";";
                        if (!imports.Contains(import))
                        {
                            f.WriteLine(import);
                            imports.Add(import);
                        }
                    }

                    if (parameters.Extends.ContainsKey(file.Name))
                    {
                        var extends = parameters.Extends[file.Name];

                        if (string.IsNullOrEmpty(extends.from))
                            continue;

                        importing = true;

                        var import = "import { " + extends.type + " } from \""
                            + extends.from + "\";";
                        if (!imports.Contains(import))
                        {
                            f.WriteLine(import);
                            imports.Add(import);
                        }
                    }

                    if (importing)
                    {
                        f.WriteLine("");
                    }

                    if (!string.IsNullOrEmpty(file.Inherits)
                        && parameters.Extends.ContainsKey(file.Name))
                    {
                        throw new InvalidOperationException($"Class cannot be inherited and Extended. File name: {file.Name}, inherits: {file.Inherits}, Extends: {parameters.Extends[file.Name]} ");
                    }

                    string inherits = null;
                    if (!string.IsNullOrEmpty(file.Inherits))
                        inherits = file.Inherits;
                    else if(parameters.Extends.ContainsKey(file.Name))
                        inherits = parameters.Extends[file.Name].type;

                    f.WriteLine(
                        (parameters.ConvertToType == ConvertToType.Interface ? "export interface " : "export class ")
                        + file.Name
                        + (string.IsNullOrEmpty(inherits) ? "" : (" extends " + inherits)) //if class has inheritance
                        + (!parameters.Implements.ContainsKey(file.Name) ? "" : (" implements " + parameters.Implements[file.Name].type))
                        + " {"
                        );

                    foreach (var obj in file.Objects)
                    {
                        if (obj.IsContainer)
                        {
                            var str =
                                (parameters.ConvertToType == ConvertToType.Interface ? "" : "public ")
                                + ConvertServiceHelper.ToCamelCase(obj.VariableName)
                                + (obj.IsOptional ? "?" : string.Empty)
                                + ": "
                                + $"{obj.Type}<{obj.Container[0].Type}, {obj.Container[1].Type}>;";

                            f.WriteLine("    " + str);
                        }
                        else if (!string.IsNullOrEmpty(obj.VariableName))
                        {  //not an empty obj
                            var str =
                                (parameters.ConvertToType == ConvertToType.Interface ? "" : "public ")
                                + ConvertServiceHelper.ToCamelCase(obj.VariableName)
                                + (obj.IsOptional ? "?" : string.Empty)
                                + ": "
                                + obj.Type
                                + (obj.IsArray ? "[]" : string.Empty);
                            if (!obj.IsOptional && parameters.ConvertToType == ConvertToType.Class)
                            {
                                str += " = ";
                                if (obj.IsArray)
                                {
                                    str += "[]";
                                }
                                else
                                {
                                    if (obj.UserDefined)
                                    {
                                        var isEnum = models.Any(m => m.IsEnum && m.Name == obj.Type);
                                        if (isEnum)
                                            str += "0";
                                        else
                                            str += "new " + obj.Type + "()";
                                    }
                                    else
                                    {
                                        switch (obj.Type)
                                        {
                                            case "number":
                                                str += "0";
                                                break;
                                            case "string":
                                                str += "''";
                                                break;
                                            case "boolean":
                                                str += "false";
                                                break;
                                            case "Date":
                                                str += "new Date()";
                                                break;
                                        }
                                    }
                                }
                            }

                            str += ";";

                            f.WriteLine("    " + str);
                        }
                    }

                    f.WriteLine("}");
                }
            }
        }

        private static FileStream GetStream(string saveDir, int iteration)
        {
            try
            {
                Directory.CreateDirectory(Path.GetDirectoryName(saveDir));
                return new FileStream(saveDir, FileMode.Create, FileAccess.Write, FileShare.Read, 4096, FileOptions.SequentialScan);
            }
            catch (UnauthorizedAccessException) when (iteration < 10)
            {
                Thread.Sleep(100 * (int)Math.Pow(2, iteration));
                return GetStream(saveDir, ++iteration);
            }
            catch (DirectoryNotFoundException) when (iteration < 10)
            {
                return GetStream(saveDir, ++iteration);
            }
        }
    }
}
